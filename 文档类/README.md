***Chapter9***

 -  线程存储持续性（C++11）：多核处理器已经成为常态，程序能将计算放在并行计算的不同线程中。如果变量使用thread_local声明，则生命周期与所属的线程一样。动态存储持续性：用new分配的变量，直到delete删除为止；或程序结束为止
 -  
   ![](https://i.imgur.com/aKYkz5D.png)
 - ![](https://i.imgur.com/IGeBOka.png)
 - C++鼓励程序员使用多个文件，不同文件定义或实例化不同的程序部分。C++存储方案决定了变量保留在内存中的持时间。静态变量在整个程序执行过程中都存在。默认情况下，C++函数的链接性是外部的。动态内存使用new和delete来控制，定位new可以设定内存分配的具体起始地址。名称空间允许定义一个可在其中声明标识符命名区域，有效防止各种命名冲突

***Chapter10***
 - ![](https://i.imgur.com/TJln6IQ.png)

***Chapter11***

 - 友元只需在函数原型前加friend
 - 直接访问某个对象的私有成员，则必须是该类的友元
 - 只有接受一个参数的构造函数才能作为转换函数
 - 强制类型转换建议格式：double(name)而不是(double)name
 - 未声明explicit的话，有四种情况可进行隐式转换
 - 将类对象转化为其他基本数据类型，必须定义转换函数


***chapter12***

 - 类的所有对象共享同一个静态成员
 - 不能在类声明中初始化静态成员变量，因为声明描述了如何分配内存，但不分配内存
 - strcpy用于两个字符串
 - strncpy用于字符数组
 - 如果在构造函数中使用new来初始化指针成员，则应在析构函数中使用delete。new和delete必须相互兼容，new对应delete，new[]对应delete[]
 - 如果有多个构造函数，则必须以相同的方式使用new要么都有中括号，要么都没有
 - 应定义一个分配内存（而不是将指针指向已有内存）的复制构造函数。这样程序将能够将类对象初始化为另一个类对象。这种构造函数的原型通常如下：className(const className &)
 - 成员初始化列表，对于const类成员，必须使用这种方法
![](https://i.imgur.com/Uje2Qxv.png)
 - 队列出列
 - ![](https://i.imgur.com/7jp9dlk.png)

***重点***

 - 1、A.B则A为对象或者结构体；
 - 2、A->B则A为指针，->是成员提取，A->B是提取A中的成员B，A只能是指向类、结构、联合的指针；
 - 3、::是作用域运算符，A::B表示作用域A中的名称B，A可以是名字空间、类、结构；
 - 4、：一般用来表示继承；


***chapter13***
 - 除非要是使用默认构造函数，否则应显式调用正确的基类构造函数
 - 基类指针可以在不进行显式类型转换的情况下指向派生类对象；基类引用可以在不进行显示类型转换的情况下引用派生类对象，但都只能调用基类方法
 - ![](https://i.imgur.com/DxfioFX.png)
 - ![](https://i.imgur.com/J0SkKG8.png)
 - 派生类构造函数在初始化基类私有数据时，采用的是成员初始化列表语法
 - ![](https://i.imgur.com/M0447ag.png)
 - ![](https://i.imgur.com/phlf5nu.png)
 - ![](https://i.imgur.com/oxoBZEJ.png)
 - ![](https://i.imgur.com/1Zyha8J.png)
 - ![](https://i.imgur.com/1jgUIfH.png)

 - 通常应该给基类提供一个虚析构函数，及时不需要析构函数
 - 3.友元友元不能是虚函数，因为友元不是类成员，而只有成员才能使虚函数。如果由于这个原因引起了设计问题，可以通过让友元函数使用虚成员函数来解决。
 - 4.没有重新定义如果派生类没有重新定义函数，将使用该函数的基类版本。如果派生类位于派生链中，则将使用最新的虚函数版本，例外的情况是基类版本是隐藏
 - ![](https://i.imgur.com/a2AOXpt.png)
 - ![](https://i.imgur.com/mPZAISg.png)